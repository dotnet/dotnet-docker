# Container Vulnerability Workflow

This documented is intended to help guide you to the appropriate course of action when encountering reported vulnerabilities in the .NET container images.
Please follow the guidance below to determine the steps to take before logging an issue.
The flowchart below describes a series of questions to help determine the state of the image being reported upon.
By answering each question, it will eventually direct you to the action to help resolve your vulnerability.

Prerequisites:

* Dockerfile of the image being reported upon
  * Name of the .NET base image from that Dockerfile (e.g. `mcr.microsoft.com/dotnet/aspnet:6.0`)
* Architecture of the image being reported upon (e.g. `amd64`)
* Whether the image is a [Linux or Windows image](#how-can-i-determine-whether-my-image-is-based-on-linux-or-windows)
  * For Linux images, it's also important to [know the Linux distro](#how-can-i-determine-the-os-version-of-an-image) (e.g. `Debian`, `Alpine`, `Ubuntu`)
* [Docker installation](https://docs.docker.com/desktop) to run commands locally

```mermaid
flowchart
    ScanningLatest{A. Is your scanner<br>targeting the latest<br>version of your image?} --> |No|RescanLatest[B. Scan your<br>latest image]
    ScanningLatest --> |Yes|BuiltOnSupportedBase{C. Is your image<br>built from a supported<br>.NET base image?}
    BuiltOnSupportedBase --> |No|UpdateBaseImageTag[D. Update base image tag<br>to supported image]
    BuiltOnSupportedBase --> |Yes|BuiltOnLatestBase{E. Is your image<br>built from the latest<br>.NET base image?}
    BuiltOnLatestBase --> |No|RebuildImageBase[F. Rebuild your image<br>to get latest base]
    BuiltOnLatestBase --> |Yes|PlatformType{G. Which OS<br>platform is<br>this for?}
    PlatformType --> |Linux|LinuxFixAvailability{H. Is a fix available<br>for the package<br>from the Linux distro?}
    PlatformType --> |Windows|WindowsVulnSource{O. What is the<br>source of the<br>vulnerability?}
    LinuxFixAvailability --> |No|WaitForFix[I. Wait for a fix to be available<br>from the Linux distro]
    LinuxFixAvailability --> |Yes|InLinuxBaseImage{J. Is the package in<br>the Linux distro<br>base image?}
    InLinuxBaseImage --> |Yes|WaitForLinuxBaseUpdate[K. Wait for an updated Linux<br>distro base image]
    InLinuxBaseImage --> |No|InstalledByDotnet{L. Is the package<br>installed by .NET?}
    InstalledByDotnet --> |Yes|HiSeverity{M. Is it High/Critical<br>severity?}
    InstalledByDotnet --> |No|RebuildImagePackage[N. Rebuild your image<br>to get the latest package]
    HiSeverity --> |No|WaitForDotnetServicing[P. Wait for the next .NET<br>servicing release]
    HiSeverity --> |Yes|LogDotnetDocker[Q. Log an issue at<br>dotnet/dotnet-docker]
    WindowsVulnSource --> |.NET or<br> Don't Know|LogDotnetDocker
    WindowsVulnSource --> |Windows|WindowsVuln[R. Log an issue at<br>microsoft/Windows-Containers]
    click ScanningLatest "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?a-is-your-scanner-targeting-the-latest-version-of-your-image"
    click RescanLatest "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?b-scan-your-latest-image"
    click BuiltOnSupportedBase "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?c-is-your-image-built-from-a-supported-net-tag"
    click UpdateBaseImageTag "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?d-update-base-image-tag-to-supported-image"
    click BuiltOnLatestBase "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?e-is-your-image-built-from-the-latest-net-base-image"
    click RebuildImageBase "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?f-rebuild-your-image-to-get-latest-base"
    click PlatformType "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?g-which-os-platform-is-this-for"
    click LinuxFixAvailability "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?h-is-a-fix-available-for-the-package-from-the-linux-distro"
    click WaitForFix "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?i-wait-for-a-fix-to-be-available-from-the-linux-distro"
    click InLinuxBaseImage "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?j-is-the-package-in-the-linux-distro-base-image"
    click WaitForLinuxBaseUpdate "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?k-wait-for-an-updated-linux-distro-base-image"
    click InstalledByDotnet "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?l-is-the-package-installed-by-net"
    click HiSeverity "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?m-is-it-highcritical-severity"
    click RebuildImagePackage "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?n-rebuild-your-image-to-get-the-latest-package"
    click WindowsVulnSource "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?o-what-is-the-source-of-the-vulnerability"
    click WaitForDotnetServicing "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?p-wait-for-the-next-net-servicing-release"
    click LogDotnetDocker "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?q-log-an-issue-at-dotnetdotnet-docker"
    click WindowsVuln "https://github.com/dotnet/dotnet-docker/blob/main/documentation/vulnerability-workflow.md?r-log-an-issue-at-microsoftwindows-containers"
```

## Flowchart Details

### A. Is your scanner targeting the latest version of your image?

There's no need to spend time analyzing vulnerabilities if the scan results are not based on the latest image.
Each build of an image can potentially bring in newly released package versions which have fixes for the vulnerabilities.

Most image scanning software will output the [image digest](#what-is-an-image-digest) of the image that is being scanned in its report or logs.
Be sure that that digest represents the latest version of your image.
To determine what the latest digest of your image is run the script below.

#### Linux

Requires [PowerShell to be installed](https://learn.microsoft.com/powershell/scripting/install/installing-powershell-on-linux).

```shell
myImage="<insert-my-image-tag>"
curl -sSL https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/resolve-image-digest.ps1 | pwsh /dev/stdin $myImage
```

#### Windows

```powershell
$myImage="<insert-my-image-tag>"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
&([scriptblock]::Create((Invoke-WebRequest -UseBasicParsing 'https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/resolve-image-digest.ps1'))) $myImage
```

If the script above returns an error indicating it's unable to resolve a multi-arch tag, you'll need to provide extra parameters to the script.
The following scripts indicate how to do that.

If you're targeting Windows containers, you'll need to determine the Windows build number of the image you're targeting.
To do this, find the Windows version number that is listed on the [Windows Docker Hub page](https://hub.docker.com/_/microsoft-windows-nanoserver).
For example, if you're targeting Windows Server 2022 LTSC, look for the `ltsc2022` tag and find its corresponding build number in the OS Version column.
You only need the first three parts of the version number.
In the case of Windows Server 2022, it's `10.0.20348`.
You can use a wildcard to indicate the rest of the version number.

```powershell

#### Linux

Requires [PowerShell to be installed](https://learn.microsoft.com/powershell/scripting/install/installing-powershell-on-linux).

```shell
myImage="<insert-my-image-tag>"
os="<linux|windows>" # choose "linux" or "windows"
arch="<amd64|arm|arm64>" # choose the architecture of your image
osVersion="<windows-version>" # Only used for Windows containers (e.g. "10.0.20348.*"). For Linux, leave this blank.
curl -sSL https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/resolve-image-digest.ps1 | pwsh /dev/stdin $myImage -Os $os -Architecture $arch -OsVersion $osVersion
```

#### Windows

```powershell
$myImage="<insert-my-image-tag>"
$os="<linux|windows>" # choose "linux" or "windows"
$arch="<amd64|arm|arm64>" # choose the architecture of your image
osVersion="<windows-version>" # Only used for Windows containers (e.g. "10.0.20348.*"). For Linux, leave this blank.
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
&([scriptblock]::Create((Invoke-WebRequest -UseBasicParsing 'https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/resolve-image-digest.ps1'))) $myImage -Os $os -Architecture $arch -OsVersion $osVersion
```

### B. Scan your latest image

Rerun the scan of your image using your scanning tool. Ensure you get the latest version of the image by running `docker pull <image-tag>`

### C. Is your image built from a supported .NET tag?

When .NET drops support for an image tag, it means it will no longer be updated, even when there is a new base OS image available.
This means that vulnerabilities will be reported for that image over time if it continues to be used.
Our [supported tag policy](supported-tags.md) provides detailed information about when these tags are no longer supported.
The simple rule to follow: if the tag isn't shown in our [tag listing](supported-tags.md#tag-listing), it's not supported.

This script can be used to determine if the .NET image tag is supported:

#### Linux

Requires [PowerShell to be installed](https://learn.microsoft.com/powershell/scripting/install/installing-powershell-on-linux).

```shell
dotnetImage="<insert-dotnet-image-tag>" # example: mcr.microsoft.com/dotnet/aspnet:7.0
curl -sSL https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/check-tag-support.ps1 | pwsh /dev/stdin $myImage $dotnetImage
```

#### Windows

```powershell
dotnetImage="<insert-dotnet-image-tag>" # example: mcr.microsoft.com/dotnet/aspnet:7.0
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
&([scriptblock]::Create((Invoke-WebRequest -UseBasicParsing 'https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/check-tag-support.ps1'))) $dotnetImage
```

### D. Update base image tag to supported image

Switching to a supported base image tag requires knowing the specific tag usage:

* If you're using an out-of-support .NET version, such as .NET 5, you'll need to upgrade your project and Dockerfiles to target a supported version.
* If you're using a patch version tag which which has been replaced by a newer patch version, you'll need to switch to the latest patch version. For example, `6.0.8` => `6.0.9`
* If you're using a version-specific Alpine Linux tag for a version of Alpine that is no longer being maintained via .NET container images, you'll need to move to the latest version. For example, `6.0-alpine3.15` => `6.0-alpine3.16`
* If you're using a tag for a specific Windows version that is no longer supported, you'll need to move to a supported version of Windows. For example, `6.0-nanoserver-20H2` => `6.0-nanoserver-ltsc2022`

See our [supported tag policy](supported-tags.md) for more information.

### E. Is your image built from the latest .NET base image?

A given .NET tag can be updated multiple times over its a lifetime, pointing to a new image each time.
Some of these updates may contain security fixes.
Even though you may be using a supported tag, it's possible you're using an older image that has since been replaced by a newer version with that same tag.
Run one of the scripts below to determine whether your image is built on the latest image for that tag. Provide the [image digest](#what-is-an-image-digest) of your image and tag of the .NET base image (e.g. `mcr.microsoft.com/dotnet/aspnet:6.0`) as input.

A result of `True` means that your image is built from the latest .NET base image.
A result of `False` means it is not built on the latest.

#### Linux

Requires [PowerShell to be installed](https://learn.microsoft.com/powershell/scripting/install/installing-powershell-on-linux).

```shell
myImage="<insert-my-image-digest>" # format: <registry>/<repo>@sha256:<digest>
dotnetBaseImage="<insert-dotnet-base-image-tag>" # example: mcr.microsoft.com/dotnet/aspnet:7.0
curl -sSL https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/check-latest-bash.ps1 | pwsh /dev/stdin $myImage $dotnetBaseImage
```

#### Windows

```powershell
$myImage="<insert-my-image-digest>" # format: <registry>/<repo>@sha256:<digest>
$dotnetBaseImage="<insert-dotnet-base-image-tag>" # example: mcr.microsoft.com/dotnet/aspnet:7.0
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
&([scriptblock]::Create((Invoke-WebRequest -UseBasicParsing 'https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/check-latest-bash.ps1'))) $myImage $dotnetBaseImage
```

### F. Rebuild your image to get latest base

Since your image is out of date with the latest version of the .NET base image, rebuilding it will ensure it's up-to-date.
Be sure that your workflow explicitly pulls the .NET base image tag rather than using a potentially cached version of it.

### G. Which OS platform is this for?

See [How can I determine whether my image is based on Linux or Windows?](#how-can-i-determine-whether-my-image-is-based-on-linux-or-windows).

### H. Is a fix available for the package from the Linux distro?

A quick way to determine whether an updated package is available is by running the following commands:

#### Debian/Ubuntu

```shell
docker pull <my-image-digest>
docker run --rm --entrypoint /bin/sh <my-image-digest> -c "apt update > /dev/null && apt list --upgradable"
```

#### Alpine

```shell
docker pull <my-image-digest>
docker run --rm --entrypoint /bin/sh <my-image-digest> -c "apk update > /dev/null && apk list -u"
```

Each Linux distribution maintains there own version of software components, made available in their package repositories.
Each version of the Linux distro also has its own package repository.
So it's possible that a fixed package may be available in one Linux distro version but not another.
It's necessary to check with the Linux distro security site to determine whether a fix is even available for the particular vulnerability.

Your image vulnerability scanner will output an identifer of the vulnerability. This will typically be a CVE number. (Debian also has its own Debian Security Advisory (DSA) numbers).

* Debian: <https://security-tracker.debian.org/tracker>
* Ubuntu: <https://ubuntu.com/security/cves>
* Alpine: <https://security.alpinelinux.org>

Search for the vulnerability ID on the relevant Linux distro's security site.
If you don't know which Linux distro is relevant for your image, [look up the image tag](https://hub.docker.com/_/microsoft-dotnet) and it will tell you its OS version in the tag listing table.

It's important that you determine whether a fix is available for the specific version of the Linux distro.
For example, a package may have a vulnerability fixed for Debian 11 but not yet available for Debian 10.
While you could configure the Debian 10 container to install that package from the Debian 11 package repository, that doesn't mean the package will actually be compatible.
Doing so is not a supported configuration from .NET's perspective and we will not take such an action with our images.

### I. Wait for a fix to be available from the Linux distro

.NET is dependent on the Linux distribution maintainers to produce fixed versions of the packages that are contained in the .NET container images.
We can't take any action if a fixed version of the package isn't available from the package repository of the Linux distro version.
Sometimes fixes aren't ever made available because they are low severity or not applicable in container environments.
Questions on this matter should be directed to the relevant Linux distro.
If you're not already using [Alpine Linux](../samples/selecting-tags.md#alpine), you may want to consider using it instead because of its security focus and low number of vulnerabilities.

### J. Is the package in the Linux distro base image?

It's important to determine whether the Linux package in question is installed by the layers of the Linux distro base image rather than the layers of the .NET image.
You'll first need to [determine the image tag of the Linux distro base image](#how-can-i-determine-the-tag-of-the-linux-distro-image-that-my-image-is-based-upon).
Then you can execute the script below to determine whether the package is installed by the Linux distro base image.

#### Linux

Requires [PowerShell](https://learn.microsoft.com/powershell/scripting/install/installing-powershell-on-linux) and [Syft](https://github.com/anchore/syft) to be installed.

```shell
imageName="<insert-linux-base-image-name>"
curl -sSL https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/check-package-install.ps1 | pwsh /dev/stdin $imageName
```

#### Windows

Requires [Syft](https://github.com/anchore/syft) to be installed.

```powershell
$imageName="<insert-linux-base-image-name>"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
&([scriptblock]::Create((Invoke-WebRequest -UseBasicParsing 'https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/check-package-install.ps1'))) $imageName
```

### K. Wait for an updated Linux distro base image

.NET is dependent on the Linux distribution maintainers to produce updated versions of the base images that are used by the .NET container images.
Since the vulnerable package is contained in the Linux distro base image, you'll need to wait until a new version of the base image is available that contains the fixed package.
Once that is available, the .NET image will be updated to use it.
See our [image update policy](../README.md#image-update-policy) for more details.

### L. Is the package installed by .NET

Run the script below to determine whether the package is installed by one of the .NET image layers.
This script is only accurate if you've first [determined that the package is not installed by the Linux distro base image](#j-is-package-in-linux-distro-base-image) so make sure you've followed that part of the workflow first.

#### Linux

Requires [PowerShell to be installed](https://learn.microsoft.com/powershell/scripting/install/installing-powershell-on-linux).

```shell
imageName="<insert-dotnet-base-image-name>" # example: mcr.microsoft.com/dotnet/aspnet:7.0
curl -sSL https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/check-package-install.ps1 | pwsh /dev/stdin $imageName
```

#### Windows

```powershell
$imageName="<insert-linux-base-image-name>" # example: mcr.microsoft.com/dotnet/aspnet:7.0
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
&([scriptblock]::Create((Invoke-WebRequest -UseBasicParsing 'https://raw.githubusercontent.com/dotnet/dotnet-docker/main/documentation/scripts/check-package-install.ps1'))) $imageName
```

### M. Is it High/Critical severity?

The severity of a vulnerability is indicated by its Common Vulnerability Scoring System (CVSS) base score.
To find this score, search for the CVE at the [CVE site](https://www.cve.org/SiteSearch).
The score will consist of both a number and a label.
Note whether the label indicates "High" or "Critical".

### N. Rebuild your image to get the latest package

Because the package is not installed by the Linux distro base image or .NET, it must be installed by your Dockerfile.
Check your Dockerfile to check how the package is being installed.
If no package version is specified, then you should be able to rebuild your image to get the latest version of the package.
Otherwise, you'll need to update your Dockerfile to specify the latest version of the package before rebuilding.

### O. What is the source of the vulnerability?

The title or description of the vulnerability should indicate whether it's for .NET or not.

### P. Wait for the next .NET servicing release

Given that the vulnerability does not have a high severity, it will be addressed in the next .NET servicing release.
These occur on Patch Tuesday (the second Tuesday of each month).

### Q. Log an issue at dotnet/dotnet-docker

This vulnerability can be directly addressed by the .NET team.
Log an issue at [dotnet/dotnet-docker](https://github.com/dotnet/dotnet-docker/issues/new/choose) and provide the vulnerability ID and the .NET image tag you've identified as being affected.

### R. Log an issue at microsoft/Windows-Containers

This vulnerability can be directly addressed by the Windows team.
Log an issue at [microsoft/Windows-Containers](https://github.com/microsoft/Windows-Containers/issues/new/choose) and provide the vulnerability ID and the image tag you've identified as being affected.

## Appendix

### What is an image digest?

An image digest is a unique identifier for the image.
It allows you to retrieve that specific image and know that you're getting the same version as someone else that also used that same image digest.
Contrast image digests with image tags which are mutable and cannot be relied upon for ensuring you're getting an exact version of the image every time.
An image tag can be updated multiple times over its lifetime to point to different image digests.

An image digest is a SHA256 value and has the form `sha256:<value>`.
In order to pull an image by its digest, you need to know its registry, repository name, and digest.
The digest is appended to the repository name, separated by an `@` symbol: (e.g.
`mcr.microsoft.com/dotnet/samples@sha256:1983d7d0dec846cb92e59fb01eaa3e7f3a65071ca29c7db4075edefcf20db47a`).

### How can I determine whether my image is based on Linux or Windows?

1. If you're using Docker Desktop for Windows, [change your settings](https://docs.docker.com/desktop/settings/windows/) to target Linux containers.

1. Run the following command:

    ```shell
    docker pull <insert-my-image-digest>
    ```

1. If the previous command pulled the image successfully, it is a Linux image.
If you get the error "image operating system "windows" cannot be used on this platform", it is a Windows image.

### How can I determine the tag of the Linux distro image that my image is based upon?

You'll first need to get the name of the .NET base image (e.g. `mcr.microsoft.com/dotnet/aspnet:6.0`) from your Dockerfile.
Take the tag portion of that image name and search for that tag on the [.NET Runtime Dependencies page](https://hub.docker.com/_/microsoft-dotnet-runtime-deps/) within the appropriate "Linux &lt;architecture&gt; Tags" section.
Navigate to the Dockerfile link associated with that tag.
The first `FROM` line of the Dockerfile will have the name of the Linux distro base image (e.g. `amd64/debian:bullseye-slim`).

### How can I determine the OS version of an image?

Use the appropriate command below to determine the OS version of your image.
If you get an error like the following: `unable to start container process: exec: "/bin/sh": stat /bin/sh: no such file or directory: unknown`, then you're using a security-hardened image which requires a different command.

#### Linux Container Type

```shell
docker run --rm <image-name> cat /etc/os-release
```

#### Windows Container Type

```shell
docker image inspect --format "{{ .OsVersion }}" <image-name>
```

#### Linux Hardened Images

Since Linux hardened images have no shell with which to run the commands above, you can use the following command to determine the OS version (requires the use of [Syft](https://github.com/anchore/syft)):

##### Linux

```shell
syft packages --output json -q <image-name> | jq -r .distro
```

##### PowerShell

```powershell
(syft packages --output json <image-name> | ConvertFrom-Json).distro
```

### How can I determine what Linux package version is installed?

Use the appropriate command below to determine the package version installed in your image.
If you get an error like the following: `unable to start container process: exec: "/bin/sh": stat /bin/sh: no such file or directory: unknown`, then you're using a security-hardened image which requires a different command.

#### Debian/Ubuntu Images

```shell
docker run --rm --entrypoint /bin/sh <my-image-digest> apt list <package-name>
```

#### Alpine Images

```shell
docker run --rm --entrypoint /bin/sh <my-image-digest> apk list <package-name>
```

#### Hardened Images

Since hardened images have no shell with which to run the commands above, you can use the following command to determine the package version (requires the use of [Syft](https://github.com/anchore/syft)):

##### Linux

```shell
syft packages --output json -q <my-image-digest> | jq -rc ".artifacts[] | select(.name == \"<package-name>\") | .version"
```

##### PowerShell

```powershell
((syft packages --output json <my-image-digest> | ConvertFrom-Json).artifacts | Where-Object { $_.name -eq "<package-name>" }).version
```
