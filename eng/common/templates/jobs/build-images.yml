parameters:
  name: null
  pool: {}
  matrix: {}
  dockerClientOS: null
  buildJobTimeout: 60
  commonInitStepsForMatrixAndBuild: []
  customInitSteps: []
  publishConfig: null
  noCache: false
  internalProjectName: null
  publicProjectName: null
  storageAccountServiceConnection: null

jobs:
- job: ${{ parameters.name }}
  condition: and(${{ parameters.matrix }}, not(canceled()), in(dependencies.PreBuildValidation.result, 'Succeeded', 'SucceededWithIssues', 'Skipped'))
  dependsOn:
  - PreBuildValidation
  - CopyBaseImages
  - GenerateBuildMatrix
  pool: ${{ parameters.pool }}
  strategy:
    matrix: $[ ${{ parameters.matrix }} ]
  timeoutInMinutes: ${{ parameters.buildJobTimeout }}
  variables:
    imageBuilderDockerRunExtraOptions: $(build.imageBuilderDockerRunExtraOptions)
    sbomDirectory: $(Build.ArtifactStagingDirectory)/sbom
    imageInfoHostDir: $(Build.ArtifactStagingDirectory)/imageInfo
    imageInfoContainerDir: $(artifactsPath)/imageInfo
  steps:
  - ${{ parameters.commonInitStepsForMatrixAndBuild }}
  - template: /eng/common/templates/jobs/${{ format('../steps/init-docker-{0}.yml', parameters.dockerClientOS) }}@self
    parameters:
      cleanupDocker: true
  - ${{ parameters.customInitSteps }}
  - template: /eng/common/templates/steps/set-image-info-path-var.yml@self
    parameters:
      publicSourceBranch: $(publicSourceBranch)
  - powershell: echo "##vso[task.setvariable variable=imageBuilderBuildArgs]"
    condition: eq(variables.imageBuilderBuildArgs, '')
    displayName: Initialize Image Builder Build Args
  - powershell: |
      New-Item -Path $(imageInfoHostDir) -ItemType Directory -Force

      # Reference the existing imageBuilderBuildArgs variable as an environment variable rather than injecting it directly
      # with the $(imageBuilderBuildArgs) syntax. This is to avoid issues where the string may contain single quotes $ chars
      # which really mess up assigning to a variable. It would require assigning the string with single quotes but also needing
      # to escape the single quotes that are in the string which would need to be done outside the context of PowerShell. Since
      # all we need is for that value to be in a PowerShell variable, we can get that by the fact that AzDO automatically creates
      # the environment variable for us.
      $imageBuilderBuildArgs = "$env:IMAGEBUILDERBUILDARGS $env:IMAGEBUILDER_QUEUEARGS --image-info-output-path $(imageInfoContainerDir)/$(legName)-image-info.json $(commonMatrixAndBuildOptions)"
      if ($env:SYSTEM_TEAMPROJECT -eq "${{ parameters.internalProjectName }}" -and $env:BUILD_REASON -ne "PullRequest") {
        $imageBuilderBuildArgs = "$imageBuilderBuildArgs --repo-prefix ${{ parameters.publishConfig.buildAcr.repoPrefix }} --push"
      }

      # If the pipeline isn't configured to disable the cache and a build variable hasn't been set to disable the cache
      if ("$(pipelineDisabledCache)" -ne "true" -and "${{ parameters.noCache }}" -ne "true") {
        $imageBuilderBuildArgs = "$imageBuilderBuildArgs --image-info-source-path $(versionsBasePath)$(imageInfoVersionsPath)"
      }

      echo "imageBuilderBuildArgs: $imageBuilderBuildArgs"
      echo "##vso[task.setvariable variable=imageBuilderBuildArgs]$imageBuilderBuildArgs"
    displayName: Set Image Builder Build Args
  - template: /eng/common/templates/steps/run-imagebuilder.yml@self
    parameters:
      name: BuildImages
      displayName: Build Images
      serviceConnections:
      # "name" here refers to the argument name, not the service connection name.
      # It should probably be changed to "argName".
      - name: acr
        id: ${{ parameters.publishConfig.buildAcr.serviceConnection.id }}
        tenantId: ${{ parameters.publishConfig.buildAcr.serviceConnection.tenantId }}
        clientId: ${{ parameters.publishConfig.buildAcr.serviceConnection.clientId }}
      - ${{ if parameters.storageAccountServiceConnection }}:
        - name: storage
          id: ${{ parameters.storageAccountServiceConnection.id }}
          tenantId: ${{ parameters.storageAccountServiceConnection.tenantId }}
          clientId: ${{ parameters.storageAccountServiceConnection.clientId }}
      internalProjectName: ${{ parameters.internalProjectName }}
      dockerClientOS: ${{ parameters.dockerClientOS }}
      args: >-
        build
        --manifest $(manifest)
        $(imageBuilderPaths)
        $(osVersions)
        --os-type $(osType)
        --architecture $(architecture)
        --retry
        --digests-out-var 'builtImages'
        --acr-subscription '${{ parameters.publishConfig.buildAcr.subscription }}'
        --acr-resource-group '${{ parameters.publishConfig.buildAcr.resourceGroup }}'
        $(manifestVariables)
        $(imageBuilderBuildArgs)
  - template: /eng/common/templates/steps/publish-artifact.yml@self
    parameters:
      path: $(imageInfoHostDir)
      artifactName: $(legName)-image-info-$(System.JobAttempt)
      displayName: Publish Image Info File Artifact
      internalProjectName: ${{ parameters.internalProjectName }}
      publicProjectName: ${{ parameters.publicProjectName }}
  - ${{ if and(eq(variables['System.TeamProject'], parameters.internalProjectName), ne(variables['Build.Reason'], 'PullRequest'), eq(parameters.dockerClientOS, 'linux')) }}:
    - powershell: |
        $images = "$(BuildImages.builtImages)"
        if (-not $images) { return 0 }
        $syftImageName = "${{ parameters.publishConfig.publicMirrorAcr.server }}/$(imageNames.syft)"
        & $(engCommonPath)/Pull-Image.ps1 $syftImageName
        $images -Split ',' | ForEach-Object {
          echo "Generating SBOM for $_";
          $targetImageName = "$_";
          $formattedImageName = $targetImageName.Replace('${{ parameters.publishConfig.buildAcr.server }}/${{ parameters.publishConfig.buildAcr.repoPrefix }}', "").Replace('/', '_').Replace(':', '_');
          $sbomChildDir = "$(sbomDirectory)/$formattedImageName";
          New-Item -Type Directory -Path $sbomChildDir > $null;
          docker build --output=$sbomChildDir -f $(engCommonPath)/Dockerfile.syft --build-arg SYFT_IMAGE_NAME=$syftImageName --build-arg TARGET_IMAGE_NAME=$targetImageName -t syft-sbom $(engCommonPath);
        }
      displayName: Generate SBOMs
      condition: and(succeeded(), ne(variables['BuildImages.builtImages'], ''))
  - ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
    - template: /eng/common/templates/jobs/${{ format('../steps/test-images-{0}-client.yml', parameters.dockerClientOS) }}@self
      parameters:
        condition: ne(variables.testScriptPath, '')
  - ${{ if and(eq(variables['System.TeamProject'], parameters.internalProjectName), ne(variables['Build.Reason'], 'PullRequest'), eq(parameters.dockerClientOS, 'linux')) }}:
    - template: /eng/common/templates/steps/publish-artifact.yml@self
      parameters:
        path: $(sbomDirectory)
        artifactName: $(legName)-sboms
        displayName: Publish SBOM
        internalProjectName: ${{ parameters.internalProjectName }}
        publicProjectName: ${{ parameters.publicProjectName }}
        condition: ne(variables['BuildImages.builtImages'], '')
